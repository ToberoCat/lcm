import 'dart:async';
import 'dart:io';
import 'package:build/build.dart';
import 'package:glob/glob.dart';

/// Builder that generates Dart code from LCM message definitions
class LcmBuilder implements Builder {
  @override
  final buildExtensions = const {
    '.lcm': ['.dart']
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    // Get the input LCM file
    final inputId = buildStep.inputId;
    final inputPath = inputId.path;
    
    // Generate output path - same directory, change extension
    final outputPath = inputPath.replaceAll('.lcm', '.dart');
    final outputId = AssetId(inputId.package, outputPath);

    // Find lcm-gen executable
    final lcmGen = await _findLcmGen();
    if (lcmGen == null) {
      log.warning(
        'lcm-gen not found in PATH. Please install LCM and ensure lcm-gen is in your PATH.'
      );
      return;
    }

    // Read the input file
    final inputContent = await buildStep.readAsString(inputId);
    
    // Create a temporary file for the input
    final tempDir = await Directory.systemTemp.createTemp('lcm_dart_');
    final tempInputFile = File('${tempDir.path}/input.lcm');
    await tempInputFile.writeAsString(inputContent);

    try {
      // Run lcm-gen
      final result = await Process.run(
        lcmGen,
        [
          '--dart',
          '--dart-path=${tempDir.path}',
          tempInputFile.path,
        ],
      );

      if (result.exitCode != 0) {
        log.severe(
          'lcm-gen failed with exit code ${result.exitCode}\n'
          'stdout: ${result.stdout}\n'
          'stderr: ${result.stderr}'
        );
        return;
      }

      // Find the generated Dart file
      // It should be in package/FileName.dart based on the LCM package structure
      final generatedFiles = await tempDir
          .list(recursive: true)
          .where((entity) => entity is File && entity.path.endsWith('.dart'))
          .cast<File>()
          .toList();

      if (generatedFiles.isEmpty) {
        log.severe('No Dart files were generated by lcm-gen');
        return;
      }

      // Use the first generated file (should only be one for a single input)
      final generatedFile = generatedFiles.first;
      final generatedContent = await generatedFile.readAsString();

      // Write the output
      await buildStep.writeAsString(outputId, generatedContent);
    } finally {
      // Clean up temporary directory
      await tempDir.delete(recursive: true);
    }
  }

  /// Find lcm-gen executable in PATH
  Future<String?> _findLcmGen() async {
    // Try common locations
    final candidates = [
      'lcm-gen',
      '/usr/local/bin/lcm-gen',
      '/usr/bin/lcm-gen',
    ];

    for (final candidate in candidates) {
      try {
        final result = await Process.run('which', [candidate]);
        if (result.exitCode == 0) {
          return candidate;
        }
      } catch (_) {
        // Continue to next candidate
      }
    }

    // Try running lcm-gen directly (it might be in PATH)
    try {
      final result = await Process.run('lcm-gen', ['--version']);
      if (result.exitCode == 0) {
        return 'lcm-gen';
      }
    } catch (_) {
      // lcm-gen not found
    }

    return null;
  }
}

/// Creates the LCM builder
Builder lcmBuilder(BuilderOptions options) => LcmBuilder();
