import '../parser/ast.dart';
import 'fingerprint.dart';
import 'type_mapper.dart';

/// Generates Dart code from LCM type definitions
class DartGenerator {
  final FingerprintCalculator _fingerprinter = FingerprintCalculator();
  final TypeMapper _typeMapper = TypeMapper();
  final StringBuffer _buffer = StringBuffer();
  int _indent = 0;

  /// Generate Dart code for an LCM file
  String generate(LcmFile file) {
    _buffer.clear();
    _indent = 0;

    // Generate each struct
    for (int i = 0; i < file.structs.length; i++) {
      if (i > 0) _writeln();
      _generateStruct(file.structs[i]);
    }

    return _buffer.toString();
  }

  void _generateStruct(StructDecl struct) {
    final className = _typeMapper.toPascalCase(struct.name);
    final fingerprint = _fingerprinter.computeFingerprint(struct);

    // File header
    _writeln('// LCM type definitions');
    _writeln('// This file automatically generated by lcm-dart.');
    _writeln('// DO NOT MODIFY BY HAND!!!!');
    _writeln();
    _writeln("import 'dart:convert';");
    _writeln("import 'dart:typed_data';");
    _writeln("import 'package:lcm_dart/lcm_dart.dart';");
    _writeln();

    // Doc comment
    if (struct.docComment != null) {
      for (final line in struct.docComment!.split('\n')) {
        _writeln('/// $line');
      }
    }

    // Class declaration
    _writeln('class $className implements LcmMessage {');
    _indent++;

    // Fingerprint constant - use BigInt for proper unsigned hex formatting
    final fpHex = BigInt.from(fingerprint).toUnsigned(64).toRadixString(16).padLeft(16, '0');
    _writeln('static const int LCM_FINGERPRINT = 0x$fpHex;');
    _writeln();

    // Constants
    if (struct.constants.isNotEmpty) {
      for (final constant in struct.constants) {
        final dartType = _typeMapper.mapType(constant.type);
        _writeln('static const $dartType ${constant.name} = ${constant.valueString};');
      }
      _writeln();
    }

    // Fields
    for (final member in struct.members) {
      final dartType = _getDartType(member);
      _writeln('$dartType ${member.name};');
    }
    _writeln();

    // Constructor
    _writeln('$className({');
    _indent++;
    for (final member in struct.members) {
      _writeln('required this.${member.name},');
    }
    _indent--;
    _writeln('});');
    _writeln();

    // Fingerprint getter
    _writeln('@override');
    _writeln('int get lcmFingerprint => LCM_FINGERPRINT;');
    _writeln();

    // Encode method
    _generateEncodeMethod(struct);
    _writeln();

    // Decode method
    _generateDecodeMethod(struct, className);

    _indent--;
    _writeln('}');
  }

  void _generateEncodeMethod(StructDecl struct) {
    _writeln('@override');
    _writeln('void encode(LcmBuffer buf) {');
    _indent++;

    _writeln('buf.putInt64(LCM_FINGERPRINT);');

    for (final member in struct.members) {
      if (member.dimensions.isEmpty) {
        // Scalar
        _generateEncodeScalar(member.type.fullName, member.name);
      } else {
        // Array
        _generateEncodeArray(member);
      }
    }

    _indent--;
    _writeln('}');
  }

  void _generateEncodeScalar(String lcmType, String accessor) {
    if (lcmType == 'string') {
      _writeln('final ${accessor}Bytes = utf8.encode($accessor);');
      _writeln('buf.putInt32(${accessor}Bytes.length);');
      _writeln('buf.putUint8List(${accessor}Bytes);');
    } else if (lcmType == 'boolean') {
      _writeln('buf.putUint8($accessor ? 1 : 0);');
    } else if (_typeMapper.isNumericPrimitive(lcmType)) {
      final method = _typeMapper.getEncodeMethod(lcmType);
      _writeln('buf.$method($accessor);');
    } else {
      // Custom type
      _writeln('$accessor.encode(buf);');
    }
  }

  void _generateEncodeArray(MemberDecl member) {
    final depth = member.dimensions.length;

    // Generate nested loops
    for (int d = 0; d < depth; d++) {
      final dim = member.dimensions[d];
      final indexVar = 'i$d';
      String sizeExpr;

      if (dim.isConstant) {
        sizeExpr = dim.size;
      } else {
        sizeExpr = dim.size; // Variable reference
      }

      _writeln('for (var $indexVar = 0; $indexVar < $sizeExpr; $indexVar++) {');
      _indent++;
    }

    // Generate accessor with all indices
    final accessor = StringBuffer(member.name);
    for (int d = 0; d < depth; d++) {
      accessor.write('[i$d]');
    }

    _generateEncodeScalar(member.type.fullName, accessor.toString());

    // Close loops
    for (int d = 0; d < depth; d++) {
      _indent--;
      _writeln('}');
    }
  }

  void _generateDecodeMethod(StructDecl struct, String className) {
    _writeln('static $className decode(LcmBuffer buf) {');
    _indent++;

    _writeln('final fingerprint = buf.getInt64();');
    _writeln('if (fingerprint != LCM_FINGERPRINT) {');
    _indent++;
    _writeln("throw Exception('Invalid fingerprint');");
    _indent--;
    _writeln('}');
    _writeln();

    // Decode each field
    for (final member in struct.members) {
      if (member.dimensions.isEmpty) {
        // Scalar
        _generateDecodeScalar(member.type.fullName, member.name);
      } else {
        // Array
        _generateDecodeArray(member, struct);
      }
    }
    _writeln();

    // Return constructed object
    _writeln('return $className(');
    _indent++;
    for (final member in struct.members) {
      _writeln('${member.name}: ${member.name},');
    }
    _indent--;
    _writeln(');');

    _indent--;
    _writeln('}');
  }

  void _generateDecodeScalar(String lcmType, String varName) {
    if (lcmType == 'string') {
      _writeln('final ${varName}Length = buf.getInt32();');
      _writeln('final $varName = utf8.decode(buf.getUint8List(${varName}Length));');
    } else if (lcmType == 'boolean') {
      _writeln('final $varName = buf.getUint8() != 0;');
    } else if (_typeMapper.isNumericPrimitive(lcmType)) {
      final method = _typeMapper.getDecodeMethod(lcmType);
      _writeln('final $varName = buf.$method();');
    } else {
      // Custom type
      final typeName = _typeMapper.toPascalCase(_shortName(lcmType));
      _writeln('final $varName = $typeName.decode(buf);');
    }
  }

  void _generateDecodeArray(MemberDecl member, StructDecl struct) {
    final depth = member.dimensions.length;

    // Initialize the array - use element type (starting from dim 1, not 0)
    _writeln('final ${member.name} = <${_getNestedListType(member, 1)}>[];');

    // Generate nested loops
    for (int d = 0; d < depth; d++) {
      final dim = member.dimensions[d];
      final indexVar = 'i$d';
      String sizeExpr;

      if (dim.isConstant) {
        sizeExpr = dim.size;
      } else {
        sizeExpr = dim.size; // Variable reference
      }

      _writeln('for (var $indexVar = 0; $indexVar < $sizeExpr; $indexVar++) {');
      _indent++;

      // Add inner list if not at deepest level
      if (d < depth - 1) {
        final accessor = _buildAccessor(member.name, d);
        // Use element type of dimension d+1 (which is _getNestedListType starting from d+2)
        _writeln('$accessor.add(<${_getNestedListType(member, d + 2)}>[]);');
      }
    }

    // Decode the element
    final tempVar = '${member.name}Element';
    _generateDecodeScalar(member.type.fullName, tempVar);

    // Add to array
    final accessor = _buildAccessor(member.name, depth - 1);
    _writeln('$accessor.add($tempVar);');

    // Close loops
    for (int d = 0; d < depth; d++) {
      _indent--;
      _writeln('}');
    }
  }

  String _buildAccessor(String name, int depth) {
    final buffer = StringBuffer(name);
    for (int d = 0; d < depth; d++) {
      buffer.write('[i$d]');
    }
    return buffer.toString();
  }

  String _getNestedListType(MemberDecl member, int startDim) {
    if (startDim >= member.dimensions.length) {
      return _typeMapper.mapType(member.type.fullName);
    }

    final inner = _getNestedListType(member, startDim + 1);
    return 'List<$inner>';
  }

  String _getDartType(MemberDecl member) {
    if (member.dimensions.isEmpty) {
      return _typeMapper.mapType(member.type.fullName);
    }

    // Build nested list type
    String type = _typeMapper.mapType(member.type.fullName);
    for (int i = 0; i < member.dimensions.length; i++) {
      type = 'List<$type>';
    }
    return type;
  }

  String _shortName(String fullName) {
    final dotIndex = fullName.lastIndexOf('.');
    return dotIndex >= 0 ? fullName.substring(dotIndex + 1) : fullName;
  }

  void _writeln([String text = '']) {
    if (text.isNotEmpty) {
      _buffer.write('  ' * _indent);
      _buffer.writeln(text);
    } else {
      _buffer.writeln();
    }
  }
}
